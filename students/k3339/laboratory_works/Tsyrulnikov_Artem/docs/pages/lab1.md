## Лабораторная работа: Сетевые приложения на Python (socket)

В этой лабораторной работе я реализовал пять небольших приложений на базе библиотеки `socket`. Они демонстрируют работу с UDP и TCP, обработку HTTP-запросов, многопользовательский чат с потоками, а также простой веб-сервер для учёта оценок с HTML-шаблоном. Все проекты написаны на Python и запускаются без внешних зависимостей.

## Ход выполнения

## Задание 1: UDP-приветствие
Клиент отправляет «Hello, server» и получает от сервера «Hello, client» — обмен через UDP.

_Клиент и сервер_

- Сервер (`task1/server.py`): слушает `0.0.0.0:8001/UDP`, принимает датаграммы и отвечает тем же сокетом. Логирует входящие/исходящие сообщения.
- Клиент (`task1/client.py`): отправляет фразу на `localhost:8001`, ждёт ответ и печатает его.

_Протокол_

- UDP (`socket.SOCK_DGRAM`), схема request/response, кодировка UTF‑8.

_Запуск_

- Сервер: `python task1/server.py`
- Клиент: `python task1/client.py`

## Задание 2: TCP-вычислительный сервис
Клиент запрашивает выполнение математической операции. Я выбрал вариант «Площадь трапеции»: \( S = \frac{(a + b) \cdot h}{2} \).

_Клиент и сервер_

- Сервер (`task2/server.py`): TCP на `0.0.0.0:8002`, принимает JSON с параметрами `a`, `b`, `h`, валидирует и возвращает JSON с полем `result` либо `error`.
- Клиент (`task2/client.py`): подключается к `localhost:8002`, опрашивает пользователя (безопасный парсинг чисел), отправляет JSON и печатает ответ.

_Протокол_

- TCP (`socket.SOCK_STREAM`), обмен в формате JSON, кодировка UTF‑8.

_Запуск_

- Сервер: `python task2/server.py`
- Клиент: `python task2/client.py` (ввести значения `a`, `b`, `h` при запросе)

## Задание 3: HTTP-сервер статической страницы
Сервер принимает подключение, парсит запрос и отдаёт HTML-страницу из файла `index.html`.

_Сервер_

- Реализация (`task3/server.py`): TCP на `0.0.0.0:8003`, загружает `task3/index.html`, формирует корректный HTTP-ответ с заголовками `Content-Type` и `Content-Length`. В логах фиксируются метод и путь запроса, ошибки конвертируются в страницу 500 с сообщением.

_Файл страницы_

- `task3/index.html`: адаптивный одностраничный макет без внешних зависимостей, стили встроены.

_Запуск_

- Сервер: `python task3/server.py`
- Открыть: `http://localhost:8003`

## Задание 4: Многопользовательский чат (TCP + потоки)
Реализован полноценный многопользовательский чат с широковещательной рассылкой и никнеймами. Для максимального балла использованы потоки.

_Сервер_

- `task4/server.py`: TCP на `0.0.0.0:8004`, на каждого клиента создаётся поток. Пользователи хранятся в словаре с `@dataclass ClientInfo`. Сообщения размечаются штампом времени и транслируются всем, кроме отправителя. Корректный выход — по `exit` или разрыву соединения.

_Клиент_

- `task4/client.py`: два потока — приём и отправка. На старте вводится никнейм, команды отправляются построчно; для выхода — `exit`.

_Запуск_

- Сервер: `python task4/server.py`
- Клиенты (в разных терминалах): `python task4/client.py`

## Задание 5: Веб-сервер оценок (GET/POST)
Простой HTTP-сервер, который принимает и хранит оценки по дисциплинам и отдаёт HTML-страницу со списком всех оценок.

_Сервер_

- `task5/server.py`: TCP на `0.0.0.0:8005`. Для `GET /` генерирует страницу из `template.html`, подставляя строки таблицы по данным в памяти. Для `POST /` ожидает JSON-тело с полями `subject` и `grade`, валидирует и делает 302-редирект на `/`.

_HTML-шаблон_

- `task5/template.html`: разметка формы и таблицы с использованием Bootstrap CDN. Табличные строки вставляются в плейсхолдер `{grades_rows}`.

_Особенности и допущения_

- Хранилище — в памяти процесса (список словарей). Перезапуск очищает данные.
- Для отправки оценок сервер ожидает JSON. Для быстрого теста удобно использовать `curl`/HTTPie:
  - `curl -i http://localhost:8005/`
  - `curl -i -X POST http://localhost:8005/ -H 'Content-Type: application/json' -d '{"subject":"Математика","grade":5}'`

_Запуск_

- Сервер: `python task5/server.py`
- Открыть список: `http://localhost:8005`


## Выводы
Собранный набор примеров демонстрирует базовые приёмы работы с `socket`: датаграммный обмен по UDP, надёжные соединения по TCP, ручную сборку HTTP-ответов, многопоточную обработку клиентов и примитивное серверное рендеринг-шаблона.
